---
title: "W4: Functions"
format: 
  live-revealjs:
    smaller: true
    scrollable: true
    echo: true
---

{{< include _extensions/r-wasm/live/_knitr.qmd >}}

## Announcements

-   No class next week!

-   Come back in two weeks to put all of this knowledge into a data analysis project. And then üçï for the final class the week after.

## Why Functions?

. . .

1.  Follow DRY (Don't Repeat Yourself) principle: If you find yourself repeating similar patterns of code, write a function.

. . .

2.  Create modular structure and abstraction: You only need to know the function name, inputs, and output to use it, and don't have to worry how it works. Functions can be shared with others to use.

## Anatomy of a function definition

. . .

```         
def <function name>(<input arguments>):
    """ documentation string """
    code block
    return <variable>
```

. . .

`<function name>` is the function's name you are creating.

. . .

`<input arguments>` specify the input arguments for the function as variable, separated by commas.

. . .

`""" documentation string """` describes what the function is doing. It is considered optional but [highly recommended](https://peps.python.org/pep-0257/).

. . .

`code block` performs the action of the function, typically using the input arguments of the function.

. . .

`return <variable>` as the output of the function.

## Simple example

Here's an simple example to define a function that adds two numbers together:

```{pyodide}
def add_numbers(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2
  return result
```

. . .

When this code is run, `add_numbers()` is stored in the environment, but the function is never run. To run the function,

```{pyodide}
add_numbers(3, 4)
```

. . .

When the function is called, the input values 3 and 4 are reassigned to function input arguments `num1` and `num2` to be used within the function.

. . .

We need to introduce the concept of **local** and **global** **environments** to distinguish variables used only for a function from variables used for the entire program.

## Global and Local Environments

Within a function, all input arguments and any new variables defined are stored in a "**local environment**", and is only accessible within the function's body.

The overall environment of the program is called the "**global environment**" and can be also accessed within the function.

. . .

The reason of having some of this "privacy" in the local environment is to make functions *modular:* Imagine someone writing a function you give someone else to use, but the function depends on your global environment - it would not be portable!

. . .

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20add_numbers%28num1,%20num2%29%3A%0A%20%20%22%22%22%20Adds%20two%20input%20numbers%20together.%20%22%22%22%0A%20%20result%20%3D%20num1%20%2B%20num2%0A%20%20return%20result%0A%20%20%0Aadd_numbers%283,%204%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">

</iframe>

If it doesn't load properly, here is the [link](https://pythontutor.com/render.html#code=def%20add_numbers%28num1,%20num2%29%3A%0A%20%20%22%22%22%20Adds%20two%20input%20numbers%20together.%20%22%22%22%0A%20%20result%20%3D%20num1%20%2B%20num2%0A%20%20return%20result%0A%20%20%0Aadd_numbers%283,%204%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=311&rawInputLstJSON=%5B%5D&textReferences=false).


## What if You don't return a result?

What happens if you don't return a value?

```{pyodide}
def add_numbers2(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2

add_numbers2(2, 4)
```

- Functions as we will use them will usually *return* a value
- There are some methods that don't return anything, such as `my_list.sort()`

## Using Named Arguments

In general, when there are more than 2 inputs, I like to use named arguments:

```{pyodide}
def add_numbers(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2
  return result

add_numbers(num1 = 2, num2 = 5)
```

## Checking for Inputs

What happens if you use `Strings` in our function?

```{pyodide}
def add_numbers(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2
  return result

add_numbers(num1 = "My name is ", num2 = "Ted")
```

Adding strings is defined in Python!

Think about checking for the datatypes for your argument

## Function arguments create modularity

Why are variables we use for the arguments of a function *reassigned* for function arguments in the local environment? Here is an example when that process is skipped:

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=x%20%3D%203%0Ay%20%3D%204%0A%0Adef%20add_numbers%28num1,%20num2%29%3A%0A%20%20%22%22%22%20Adds%20two%20input%20numbers%20together.%20%22%22%22%0A%20%20result%20%3D%20x%20%2B%20y%0A%20%20return%20result%0A%20%20%0Aadd_numbers%28x,%20y%29%0A%0Aadd_numbers%2810,%20-5%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">

</iframe>

If it doesn't load properly, here is the [link](https://pythontutor.com/render.html#code=x%20%3D%203%0Ay%20%3D%204%0A%0Adef%20add_numbers%28num1,%20num2%29%3A%0A%20%20%22%22%22%20Adds%20two%20input%20numbers%20together.%20%22%22%22%0A%20%20result%20%3D%20x%20%2B%20y%0A%20%20return%20result%0A%20%20%0Aadd_numbers%28x,%20y%29%0A%0Aadd_numbers%2810,%20-5%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=311&rawInputLstJSON=%5B%5D&textReferences=false).

## Practice!

-   Write a function, `my_abs(x)` that 
1. computes the absolute value of an input numeric value and returns it. 

Use cases: `my_abs(-3) = 3`, `my_abs(0) = 0`, `my_abs(33) = 33`. 

You will need to use conditional statements within the body of the function.

```{pyodide}
## Write your function here
function my_abs(x):
  

print(my_abs(-3))
```

## Practice 2

Write a function, `my_abs_iterated(x)` that 

1. takes in a list of numerical values and 
2. use `my_abs(x)` to take the absolute value of each element. 

Use cases: `my_abs_iterated([3, -9, 2]) = [3, 9, 2]`.

```{pyodide}
##Write your function here
function my_abs_iterated(x):


print(my_abs_iterated([3, -9, 2]))
```

## How's the pace going for you?

<https://forms.gle/6s8x8h5dDudmeqSu6>
