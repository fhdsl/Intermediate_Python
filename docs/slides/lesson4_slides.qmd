---
title: "W4: Functions"
format: 
  live-revealjs:
    smaller: true
    scrollable: true
    echo: true
---

{{< include _extensions/r-wasm/live/_knitr.qmd >}}

# 20 Minutes of Catchup Time

```{r}
countdown::countdown(minutes=20)
```

# Hit Record in Teams

## Announcements

-   No class next week!
-   Come back in two weeks to put all of this knowledge into a data analysis project. And then üçï for the final class the week after.

## f-strings

Using an `f""` in front of our string allows us to do variable substitution. Anything in the string that is surrounded by `{}` python will interpret as a variable.

```{pyodide}
nums = [3,4,5,7]
for num in nums:
  print(f"On Number: {num}")
```

<https://www.geeksforgeeks.org/python/formatted-string-literals-f-strings-python/>



## Indenting Matters

Anyone spot the mistake here?

```{pyodide}
total = 0
nums = [3,4,5,7]

for num in nums:
  print("On Number " + num)

total = total + num

print(total)
```


## Why Functions?

. . .

1.  Follow DRY (Don't Repeat Yourself) principle: If you find yourself repeating similar patterns of code, write a function.

. . .

2.  Create modular structure and abstraction: You only need to know the function name, inputs, and output to use it, and don't have to worry how it works. Functions can be shared with others to use.

## Anatomy of a function definition {auto-animate=true}

:::: {.columns}

::: {.column width="40%"}
```{python}
#| eval: false
#| code-line-numbers: "1"
def <function name>(<input arguments>): # <1>
    """ documentation string """  #<2>
    code block                    #<3>
    return <variable>             #<4>
```

:::

::: {.column width="60%"}
1. `<function name>` is the function's name you are creating. `<input arguments>` specify the input arguments for the function as variable, separated by commas.
:::

::::


## Anatomy of a function definition {auto-animate=true}

:::: {.columns}

::: {.column width="40%"}
```{python}
#| eval: false
#| code-line-numbers: "2"
def <function name>(<input arguments>): # <1>
    """ documentation string """  #<2>
    code block                    #<3>
    return <variable>             #<4>
```

:::

::: {.column width="60%"}
1. `<function name>` is the function's name you are creating. `<input arguments>` specify the input arguments for the function as variable, separated by commas.
2. `""" documentation string """` describes what the function is doing. It is considered optional but [highly recommended](https://peps.python.org/pep-0257/).

:::

::::




## Anatomy of a function definition {auto-animate=true}

:::: {.columns}

::: {.column width="40%"}
```{python}
#| eval: false
#| code-line-numbers: "3"
def <function name>(<input arguments>): # <1>
    """ documentation string """  #<2>
    code block                    #<3>
    return <variable>             #<4>
```
:::

::: {.column width="60%"}
1. `<function name>` is the function's name you are creating. `<input arguments>` specify the input arguments for the function as variable, separated by commas.
2. `""" documentation string """` describes what the function is doing. It is considered optional but [highly recommended](https://peps.python.org/pep-0257/).
3. `code block` performs the action of the function, typically using the input arguments of the function.
:::

::::





## Anatomy of a function definition {auto-animate=true}


:::: {.columns}

::: {.column width="40%"}
```{python}
#| eval: false
#| code-line-numbers: "4"
def <function name>(<input arguments>): # <1>
    """ documentation string """  #<2>
    code block                    #<3>
    return <variable>             #<4>
```

:::

::: {.column width="60%"}
1. `<function name>` is the function's name you are creating. `<input arguments>` specify the input arguments for the function as variable, separated by commas.
2. `""" documentation string """` describes what the function is doing. It is considered optional but [highly recommended](https://peps.python.org/pep-0257/).
3. `code block` performs the action of the function, typically using the input arguments of the function.
4. `return <variable>` as the output of the function.
:::

::::





## Simple example

Here's an simple example to define a function that adds two numbers together:

```{python}
#| eval: false
def add_numbers(num1, num2): # <1>
  """ Adds two input numbers together. """ # <2>
  result = num1 + num2 # <3>
  return result      # <4>
```

1. `<function name>` is the function's name you are creating. `<input arguments>` specify the input arguments for the function as variable, separated by commas.
2. `""" documentation string """` describes what the function is doing. It is considered optional but [highly recommended](https://peps.python.org/pep-0257/).
3. `code block` performs the action of the function, typically using the input arguments of the function.
4. `return <variable>` as the output of the function.

## Simple example

Here's an simple example to define a function that adds two numbers together:

```{pyodide}
def add_numbers(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2
  return result
```

. . . 

When this code is run, `add_numbers()` is stored in the environment, but the function is never run. To run the function,

```{pyodide}
add_numbers(3, 4)
```

. . .

When the function is called, the input values 3 and 4 are reassigned to function input arguments `num1` and `num2` to be used within the function.

. . .

We need to introduce the concept of **local** and **global** **environments** to distinguish variables used only for a function from variables used for the entire program.

## Global and Local Environments

Within a function, all input arguments and any new variables defined are stored in a "**local environment**", and is only accessible within the function's body.

The overall environment of the program is called the "**global environment**" and can be also accessed within the function.

. . .

The reason of having some of this "privacy" in the local environment is to make functions *modular:* Imagine someone writing a function you give someone else to use, but the function depends on your global environment - it would not be portable!

. . .

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20add_numbers%28num1,%20num2%29%3A%0A%20%20%22%22%22%20Adds%20two%20input%20numbers%20together.%20%22%22%22%0A%20%20result%20%3D%20num1%20%2B%20num2%0A%20%20return%20result%0A%20%20%0Aadd_numbers%283,%204%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">

</iframe>

If it doesn't load properly, here is the [link](https://pythontutor.com/render.html#code=def%20add_numbers%28num1,%20num2%29%3A%0A%20%20%22%22%22%20Adds%20two%20input%20numbers%20together.%20%22%22%22%0A%20%20result%20%3D%20num1%20%2B%20num2%0A%20%20return%20result%0A%20%20%0Aadd_numbers%283,%204%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=311&rawInputLstJSON=%5B%5D&textReferences=false).

## Function variables and scope

Variables defined in a function can't be used outside of a function:

```{pyodide}
def add_numbers(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2
  return result

print(add_numbers(1,4))
print(result)
```


## Arguments and Scope

Arguments act as inputs to the function. It's best to act as if the function can't see anything except the inputs to the function.

We can't access the value of our argument outside of calling the function:

```{pyodide}
add_numbers(num1 = 1, num2 = 4)

num1
```

## What if You don't return a result?

What happens if you don't return a value?

```{pyodide}
def add_numbers2(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2

add_numbers2(2, 4)
```

- Functions as we will use them will usually *return* a value
- There are some methods that don't return anything, such as `my_list.sort()`

## Using Named Arguments

In general, when there are more than 2 inputs, I like to use named arguments:

```{pyodide}
def add_numbers(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2
  return result

add_numbers(num1 = 2, num2 = 5)
```

## Checking for Inputs

What happens if you use `Strings` in our function?

```{pyodide}
def add_numbers(num1, num2):
  """ Adds two input numbers together. """
  result = num1 + num2
  return result

add_numbers(num1 = "My name is ", num2 = "Ted")
```

Adding strings is defined in Python!

## Checking for Inputs

Think about checking for the datatypes for your argument. 

```{pyodide}
def add_numbers(num1, num2):
  """ Adds two input numbers together. """
  if type(num1) is not int:
    raise TypeError("Expected Int input")
    
  result = num1 + num2
  return result

add_numbers(num1 = "My name is ", num2 = "Ted")
```


## Function arguments create modularity

Why are variables we use for the arguments of a function *reassigned* for function arguments in the local environment? Here is an example when that process is skipped:

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=x%20%3D%203%0Ay%20%3D%204%0A%0Adef%20add_numbers%28num1,%20num2%29%3A%0A%20%20%22%22%22%20Adds%20two%20input%20numbers%20together.%20%22%22%22%0A%20%20result%20%3D%20x%20%2B%20y%0A%20%20return%20result%0A%20%20%0Aadd_numbers%28x,%20y%29%0A%0Aadd_numbers%2810,%20-5%29&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">

</iframe>

If it doesn't load properly, here is the [link](https://pythontutor.com/render.html#code=x%20%3D%203%0Ay%20%3D%204%0A%0Adef%20add_numbers%28num1,%20num2%29%3A%0A%20%20%22%22%22%20Adds%20two%20input%20numbers%20together.%20%22%22%22%0A%20%20result%20%3D%20x%20%2B%20y%0A%20%20return%20result%0A%20%20%0Aadd_numbers%28x,%20y%29%0A%0Aadd_numbers%2810,%20-5%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=311&rawInputLstJSON=%5B%5D&textReferences=false).

## Practice!

-   Write a function, `my_abs(x)` that 
1. computes the absolute value of an input numeric value and returns it. 

Use cases: `my_abs(-3) = 3`, `my_abs(0) = 0`, `my_abs(33) = 33`. 

You will need to use conditional statements within the body of the function.

```{pyodide}
## Write your function here
function my_abs(x):
  

print(my_abs(-3))
```

## Practice 2

Write a function, `my_abs_iterated(x)` that 

1. takes in a list of numerical values and 
2. use `my_abs(x)` to take the absolute value of each element. 

Use cases: `my_abs_iterated([3, -9, 2]) = [3, 9, 2]`.

```{pyodide}
##Write your function here
function my_abs_iterated(x):


print(my_abs_iterated([3, -9, 2]))
```

## How's the pace going for you?

<https://forms.gle/6s8x8h5dDudmeqSu6>
