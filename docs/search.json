[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Intermediate Python",
    "section": "",
    "text": "About this course\nThe course continues building programming fundamentals in Python programming and data analysis. You will learn how to make use of complex data structures, iterate repeated tasks that scales naturally, and create your own functions. You will apply these skills to develop a custom data analysis.",
    "crumbs": [
      "About this course"
    ]
  },
  {
    "objectID": "index.html#target-audience",
    "href": "index.html#target-audience",
    "title": "Intermediate Python",
    "section": "Target Audience",
    "text": "Target Audience\nThe course is intended for researchers who want to continue learning the fundamentals of Python programming and how to write custom data analysis functions when dealing with messy datasets. The audience should know how to work with Lists and Pandas Dataframes and conduct basic data analysis, and/or have taken our Intro to Python course.",
    "crumbs": [
      "About this course"
    ]
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Intermediate Python",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand and distinguish the use case of data structures to store different types of data.\nImplement code to Iterate over a collection (such as files, elements of a column, or a list of objects) to batch process each item.\nImplement code that has a branching structure depending on input data’s condition.\nCreate simple, modular functions that can be reused.\nDescribe the difference between copying an object vs. referencing an object and how that could affect variables in a data analysis.",
    "crumbs": [
      "About this course"
    ]
  },
  {
    "objectID": "index.html#offerings",
    "href": "index.html#offerings",
    "title": "Intermediate Python",
    "section": "Offerings",
    "text": "Offerings\nThis course is taught on a regular basis at Fred Hutch Cancer Center through the Data Science Lab. Announcements of course offering can be found here.",
    "crumbs": [
      "About this course"
    ]
  },
  {
    "objectID": "01-Fundamentals.html",
    "href": "01-Fundamentals.html",
    "title": "1  Fundamentals",
    "section": "",
    "text": "1.1 Goals of this course",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#goals-of-this-course",
    "href": "01-Fundamentals.html#goals-of-this-course",
    "title": "1  Fundamentals",
    "section": "",
    "text": "Continue building programming fundamentals: How to use complex data structures, create custom functions, and how to iterate repeated tasks.\nContinue exploration of data science fundamentals: how to clean messy data using the programming fundamentals above to a Tidy form for analysis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#motivation",
    "href": "01-Fundamentals.html#motivation",
    "title": "1  Fundamentals",
    "section": "1.2 Motivation",
    "text": "1.2 Motivation\nWe will be looking at a dataset from Twitter that looks like the following:\n\n\n\n\n\n\n\n\n\n\n\nTweet_ID\nUsername\nText\nRetweets\nLikes\nTimestamp\n\n\n\n\n1\njulie81\nParty least receive say or single….\n2\n25\n2023-01-30 11:00:51\n\n\n2\nrichardhester\nHotel still Congress may member staff….\n35\n29\n2023-01-02 22:45:58\n\n\n3\nwilliamsjoseph\nNice be her debate industry that year….\n51\n25\n2023-01-18 11:25:19\n\n\n\nSuppose that we want to do some text analysis on the “Text” column: We want to assign a sentiment score (a numerical value that measures the emotional tone or attitude expressed in text) to each tweet, based on all of the words it contains. For instance, a tweet about celebrating one’s birthday will be assigned a positive sentiment score, and a tweet about getting fired from a job will be assigned a negative sentiment score.\nIf we have a function that takes in a String of words, and output a sentiment score, that would be great. However, that function does not exist in the built-in libraries of Python and Pandas, so we will have to write our custom function!\nWhen we think about writing a custom function, we usually like to sketch out an outline what the function will do in English, and then try to translate it to Python code.\nGiven an input String of words,\n\nExamine each word in the input string:\n\nAssociate the word with a sentiment score.\nAnd keep track of this sentiment score.\n\nTake the average of all the sentiment scores,\nand return it as the output.\n\nHow do we associate a word with a sentiment score? We need another function to do that:\nGiven an input String with one word,\n\nLoad in a “lookup dictionary” that assigns words to scores.\nCheck whether the input string is in the dictionary. Some words, such as “the”, won’t have a sentiment score.\nIf so, return the score of that word.\n\nSome concepts from this outline that we will learn the technical details include: writing a custom function, iterating through a data structure, and using “lookup dictionaries”. Let’s look at the Learning Objectives of the course:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#learning-objectives",
    "href": "01-Fundamentals.html#learning-objectives",
    "title": "1  Fundamentals",
    "section": "1.3 Learning Objectives",
    "text": "1.3 Learning Objectives\n\nUnderstand and distinguish the use case of data structures to store different types of data.\nImplement code to Iterate over a collection (such as files, elements of a column, or a list of objects) to batch process each item.\nImplement code that has a branching structure depending on input data’s condition.\nCreate simple, modular functions that can be reused.\nDescribe the difference between copying an object vs. referencing an object and how that could affect variables in a data analysis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#data-types-in-python",
    "href": "01-Fundamentals.html#data-types-in-python",
    "title": "1  Fundamentals",
    "section": "1.4 Data types in Python",
    "text": "1.4 Data types in Python\nTo get started, let’s recall the primitive data types in Python:\n\n\n\nData type name\nData type shorthand\nExamples\n\n\n\n\nInteger\nint\n2, 4\n\n\nFloat\nfloat\n3.5, -34.1009\n\n\nString\nstr\n“hello”, “234-234-8594”\n\n\nBoolean\nbool\nTrue, False\n\n\n\nThere’s a special data type called None in Python, in which is used as a placeholder. We will talk about it later this course.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#data-structures",
    "href": "01-Fundamentals.html#data-structures",
    "title": "1  Fundamentals",
    "section": "1.5 Data Structures",
    "text": "1.5 Data Structures\nAnd fundamental data structures:\n\nList\nDataframe\nSeries\nDictionary\nTuple\n\nWe will look at our new data structure, the Dictionary, carefully today. You will learn a little bit about Tuples in your exercise.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#objects-in-python",
    "href": "01-Fundamentals.html#objects-in-python",
    "title": "1  Fundamentals",
    "section": "1.6 Objects in Python",
    "text": "1.6 Objects in Python\nAll of our Data Structures are organized under the Objects framework in Python. For each data structure type, we can examine:\n\nWhat does it contain (in terms of data)?\nWhat can it do (in terms of functions)?\n\nAnd if it “makes sense” to us, then it is well-designed Object.\nFormally, an object contains the following:\n\nValue that holds the essential data for the object.\nAttributes that hold subset or additional data for the object.\nFunctions called Methods that are for the object and have to take in the variable referenced as an input.\n\nThis organizing structure on an object applies to pretty much all Python data types and data structures.\nLet’s see how this applies to the Dataframe:\nSuppose we have the following Dataframe:\n\nimport pandas as pd\n\nsimple_df = pd.DataFrame(data={'id': [\"AAA\", \"BBB\", \"CCC\", \"DDD\", \"EEE\"],\n                               'case_control': [\"case\", \"case\", \"control\", \"control\", \"control\"],\n                               'measurement1': [2.5, 3.5, 9, .1, 2.2],\n                               'measurement2': [0, 0, .5, .24, .003],\n                               'measurement3': [80, 2, 1, 1, 2]})\nsimple_df\n\n\n\n\n\n\n\n\nid\ncase_control\nmeasurement1\nmeasurement2\nmeasurement3\n\n\n\n\n0\nAAA\ncase\n2.5\n0.000\n80\n\n\n1\nBBB\ncase\n3.5\n0.000\n2\n\n\n2\nCCC\ncontrol\n9.0\n0.500\n1\n\n\n3\nDDD\ncontrol\n0.1\n0.240\n1\n\n\n4\nEEE\ncontrol\n2.2\n0.003\n2\n\n\n\n\n\n\n\n\nValue: the contents of the Dataframe, which is a tabular data format in columns and rows.\nAttributes that allow one to access subset of the data or additional data:\n\nsimple_df.id access the column “id”, returning a Series object.\nsimple_df.shape access the the number of rows and columns.\nSubsetting via the bracket .iloc[row_idx, col_idx] or .loc[row_idx, col_idx] notation.\n\nMethods that can be used on the object:\n\nsimple_df.head() and simple_df.tail() access the first and last few elements of the Dataframe, respectively.\nsimple_df.merge(another_df) merges simple_df with another Dataframe another_df.\n\n\nWe have some of our favorite attributes and methods of Dataframes from Intro to Python here.\nTo be even more precise, even primitive data types, such as an Integer, is considered an Object in Python. We just typically access its Value, but don’t interact with its underlying Attributes and Methods.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#dictionary",
    "href": "01-Fundamentals.html#dictionary",
    "title": "1  Fundamentals",
    "section": "1.7 Dictionary",
    "text": "1.7 Dictionary\nToday, we will introduce a new data structure, called the Dictionary. A dictionary is designed as a lookup table, organized in key-value pairs. You associate the key with a particular value, and use the key to find the value. You should consider using a dictionary when you are storing a collection of associations. Another way of saying this is that dictionaries are useful for storing and manipulating correspondence relationships.\nFor instance, suppose that we want to associate common English words with a sentiment value:\n\nsentiment = {'happy': 8, 'sad': 2, 'joy': 7.5, 'embarrassed': 3.6, 'restless': 4.1, 'apathetic': 3.8, 'calm': 7}\nsentiment\n\n{'happy': 8,\n 'sad': 2,\n 'joy': 7.5,\n 'embarrassed': 3.6,\n 'restless': 4.1,\n 'apathetic': 3.8,\n 'calm': 7}\n\n\nIf we want to find the sentiment value of a word, we can look it up immediately via its key to access its value:\n\nsentiment['joy']\n\n7.5\n\n\nHowever, we cannot access the nth element of a Dictionary, as we are able to do with Lists and Series:\n\n#sentiment[0] error!\n\n\n1.7.1 Basic Rules of Dictionaries\nHere are some basic usage rules of Dictionaries:\n\nOnly one value per key. No duplicate keys allowed.\nKeys must be of string, integer, float, boolean, or tuple.\nValues can be of any type, including data structures such as lists and dictionaries.\n\nIf duplicated keys are given, then the last unique key is kept.\nduplicated_keys = {'Student' : 97, 'Student': 88, 'Student' : 91}\nduplicated_keys\nIt is quite common to have data structures within a dictionary. Notice that when we create a Dataframe from scratch, we give it a dictionary, where the column names are keys and columns are values. A Dataframe is built on top of a dictionary with more tools!\n\n\n1.7.2 Basic Usage of Dictionaries\nYou can modify values of a corresponding key in a dictionary:\n\nsentiment['joy'] = sentiment['joy'] + 1\n\nYou will get an error if you try to access a key that doesn’t exist:\n\n#sentiment['dog']\n\nAlternatively, if you don’t want to run the risk of getting an error, you can specify a default value using the .get() method. Here, we give a default neutral value of 5 if the key doesn’t exist.\n\nsentiment.get(\"dog\", 5)\n\n5\n\n\nIf you don’t specify a default value, and the key does not exist, you will get a special None data type.\n\nprint(sentiment.get(\"dog\"))\n\nNone\n\n\nYou can add more key-value pairs via my_dict[new_key] = new_value syntax. If the key already exists, the mapping for that key will simply be updated.\n\nsentiment['dog'] = 5\n\n\n\n1.7.3 Dictionary vs. List\nBoth data types help you organize values, and they differ how you access the values. You access a list’s values via a numerical index, and you access a dictionary’s values via a key.\n\n\nSource: https://open.oregonstate.education/computationalbiology/chapter/dictionaries/\n\n\n1.7.4 Application for Data Cleaning\nSuppose that you want to do some data recoding. You want to look at the “case_control” column of simple_df and change “case” to “experiment” and “control” to “baseline”. This correspondence relationship can be stored in a dictionary. You can use the .replace() method for Series objects with a dictionary as an input argument.\n\nsimple_df.case_control.replace({\"case\": \"experiment\", \"control\": \"baseline\"})\n\n0    experiment\n1    experiment\n2      baseline\n3      baseline\n4      baseline\nName: case_control, dtype: object",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#converting-between-data-types",
    "href": "01-Fundamentals.html#converting-between-data-types",
    "title": "1  Fundamentals",
    "section": "1.8 Converting between data types",
    "text": "1.8 Converting between data types\nOften, we need to convert between data types and data structures. You should consider whether the conversion is:\n\nPermissible\nWhether any information will be lost\n\n\n1.8.1 Data types\nYou can convert any number to a String.\n\nage = 24.5\nstr(age)\n\n'24.5'\n\n\nLet’s try to convert a String to a Float:\n\nage = \"24.5\"\nfloat(age)\n\n24.5\n\n\nBut it is not permissible to convert to an Integer, as we don’t know what to do with the decimals (we comment out code that will error, so that this page will render).\n\n#int(age) returns an error\n\nAnd we cannot convert some Strings to any number.\n\ncar = \"prius\"\n#float(prius) returns an error\n\nSometimes, we need to pay attention whether any information is lost in the conversion. Let’s convert Float to Int:\n\ntemperature = 98.6\nint(temperature)\n\n98\n\n\nNotice that the conversion dropped the decimal point entirely.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#converting-between-data-structures",
    "href": "01-Fundamentals.html#converting-between-data-structures",
    "title": "1  Fundamentals",
    "section": "1.9 Converting between data structures",
    "text": "1.9 Converting between data structures\nWhen we look at a column, it is of the Series data structure.\n\nsimple_df['measurement1']\n\n0    2.5\n1    3.5\n2    9.0\n3    0.1\n4    2.2\nName: measurement1, dtype: float64\n\n\nLet’s convert it to a List:\n\nsimple_df['measurement1'].to_list()\n\n[2.5, 3.5, 9.0, 0.1, 2.2]\n\n\nIf you look at the documentation of Series, there’s a lot of other conversions you can do, in the .to_*() methods, such as .to_string().\nWhen making these conversions, you might ask why isn’t the column of a Dataframe just a List instead of a Series. The answer is that there are useful values, attributes, and methods about a Series that are more useful for data analysis compared to a List. You can compute .mean() to get the average value of a Series or .plot() to make a simple plot, but these methods doe not exist for a List. Series are also designed to compute on large datasets more efficiently than Lists. However, Lists can store elements from various data types, and can store Lists within Lists. When we make conversions, we think about what data structure is more appropriate than the other, which is a big theme of this course!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#is-my-variable-a-data-typestructure",
    "href": "01-Fundamentals.html#is-my-variable-a-data-typestructure",
    "title": "1  Fundamentals",
    "section": "1.10 Is my variable a data type/structure?",
    "text": "1.10 Is my variable a data type/structure?\nOften, you need to check whether your variable is a specific data type or structure. From Intro to Python, you learned about the type() function, such as:\n\ntype(simple_df)\n\npandas.core.frame.DataFrame\n\n\nThis is great, but the output of type() can be rather verbose, and is usually useful for printing and testing scenarios. To have a more concise, robust way of checking, we prefer the isinstance() function:\n\nisinstance(simple_df, pd.DataFrame)\n\nTrue\n\n\nThis directly reference the Object’s type, which is more clear.\n\nisinstance(simple_df, list)\n\nFalse",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "01-Fundamentals.html#exercises",
    "href": "01-Fundamentals.html#exercises",
    "title": "1  Fundamentals",
    "section": "1.11 Exercises",
    "text": "1.11 Exercises\nExercise for week 1 can be found here.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fundamentals</span>"
    ]
  },
  {
    "objectID": "02-Iteration.html",
    "href": "02-Iteration.html",
    "title": "2  Iteration",
    "section": "",
    "text": "2.1 Iterable Data Structures\nIt turns out that we can iterate over many types of data structures in Python. These Data Structures are considered as “Iterable”:\nWhen a data structure is considered iterable, there are a few things you can do with it:\nYou have seen examples of the first three actions already. Let’s see how we can iterate through all of these iterable data structures via the For-Loop.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "02-Iteration.html#iterable-data-structures",
    "href": "02-Iteration.html#iterable-data-structures",
    "title": "2  Iteration",
    "section": "",
    "text": "List\nTuple\nString (yes, actually!)\nSeries (but not recommended)\nDataFrame\nRanges\nDictionary\n\n\n\nAccess elements or subset of the data structure via the bracket [ ] operator.\nUse the in, not in statements to check for presence of an element in the data structure.\nExamine the length via len().\nIterate through the data structure via a For-Loop.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "02-Iteration.html#for-loops",
    "href": "02-Iteration.html#for-loops",
    "title": "2  Iteration",
    "section": "2.2 For Loops",
    "text": "2.2 For Loops\nA “For-Loop” allows you to iterate over an iterable data structure, and execute a block of code once for each iteration. Here is what the syntax looks like:\nfor &lt;variable&gt; in &lt;iterable&gt;:\n    block of code\n\n2.2.1 Example: Iterating through a List\nThe following code will iterate through each element of the list heartrates and print out each element:\n\nheartrates = [68, 54, 72, 66, 90, 102]\nfor rate in heartrates:\n  print(\"Current heartrate:\", rate)\n\nCurrent heartrate: 68\nCurrent heartrate: 54\nCurrent heartrate: 72\nCurrent heartrate: 66\nCurrent heartrate: 90\nCurrent heartrate: 102\n\n\nHere is what the Python interpreter is doing:\n\nAssign heartrates as a list.\nEnter For-Loop: rate is assigned to the next element of heartrates. If it is the first time, rate is assigned as the first element of heartrates.\nThe “block of code” in the indented section is run, and the rate is printed.\nSteps 2 and 3 are repeated until the last element of heartrates.\n\nNow you see why it’s called a “For-Loop”: for an element of the iterable data structure, do the “block of code”, and loop back to the top for the next element. You can have multiple lines of code in the indented section for the block of code.\n\n\n2.2.2 Example: Iterating through a List and summing its total\nThe following code will add up all the elements of a list:\n\nheartrates = [68, 54, 72, 66, 90, 102, 49]\ntotal = 0\n\nfor rate in heartrates:\n  total = total + rate\n  print(\"Current total:\", total)\n  \nprint(\"Final total:\", total)\n\nCurrent total: 68\nCurrent total: 122\nCurrent total: 194\nCurrent total: 260\nCurrent total: 350\nCurrent total: 452\nCurrent total: 501\nFinal total: 501\n\n\nWe just reconstructed the sum() function!\nAnother way of seeing what happened is to use the following tool that allows you to step through Python code execution line-by-line and see the variables change.\n\n\nIf it doesn’t load properly, here is the link.\n\n\n2.2.3 Example: Modifying each element while iterating\nSometimes you want to modify each element of an iterable data structure. However, if you modify the variable that is changing in the For-Loop, it won’t change the original value in the data structure.\n\nimport math\n\nprint(\"Before:\", heartrates)\n\nfor rate in heartrates:\n  rate = math.log(rate)\n  \nprint(\"After:\", heartrates)\n\nBefore: [68, 54, 72, 66, 90, 102, 49]\nAfter: [68, 54, 72, 66, 90, 102, 49]\n\n\nThe code rate = math.log(rate) changes the value of rate, but it is not connected to heartrates anymore. Instead, we need to change heartrates[index], where index is an integer that goes through all the indicies of heartrates.\nWe can do this with the enumerate() function:\n\nheartrates = [68, 54, 72, 66, 90, 102, 49]\nprint(\"Before:\", heartrates)\n\nfor index, value in enumerate(heartrates):\n  print(\"Index:\", index, \"   value:\", value)\n  heartrates[index] = math.log(value)\n  #heartrates[index] = math.log(heartrates[index]) #this is okay also.\n  \nprint(\"After:\", heartrates)\n\nBefore: [68, 54, 72, 66, 90, 102, 49]\nIndex: 0    value: 68\nIndex: 1    value: 54\nIndex: 2    value: 72\nIndex: 3    value: 66\nIndex: 4    value: 90\nIndex: 5    value: 102\nIndex: 6    value: 49\nAfter: [4.219507705176107, 3.9889840465642745, 4.276666119016055, 4.189654742026425, 4.499809670330265, 4.624972813284271, 3.8918202981106265]\n\n\nWhat’s going on here? The enumerate() function returns something that resembles a list of tuples for us to iterate through, where the first element of the tuple is the iteration index, and the second element of the tuple is the iteration element. We access this tuple through the short-hand index, m at the start of the For-Loop. Let’s see what enumerate() looks like:\n\nprint(list(enumerate(heartrates)))\n\n[(0, 4.219507705176107), (1, 3.9889840465642745), (2, 4.276666119016055), (3, 4.189654742026425), (4, 4.499809670330265), (5, 4.624972813284271), (6, 3.8918202981106265)]\n\n\nLet’s see this example step by step:\n\n\nIf it doesn’t load properly, here is the link.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "02-Iteration.html#for-loops-on-other-iterable-data-structures",
    "href": "02-Iteration.html#for-loops-on-other-iterable-data-structures",
    "title": "2  Iteration",
    "section": "2.3 For-Loops on other iterable data structures",
    "text": "2.3 For-Loops on other iterable data structures\n\n2.3.1 Tuple\nYou can loop through a Tuple just like you did with a List, but remember that you can’t modify it!\n\n\n2.3.2 String\nYou can loop through a String by iterating on each letter within the String.\n\nmessage = \"I am hungry\"\nfor text in message:\n  print(text)\n\nI\n \na\nm\n \nh\nu\nn\ng\nr\ny\n\n\nHowever, Strings are immutable, similar to Tuples. So if you iterate via enumerate(), you won’t be able to modify the original String.\n\n\n2.3.3 Dictionary\nWhen you loop through a Dictionary, you loop through the Keys of the Dictionary:\n\nsentiment = {'happy': 8, 'sad': 2, 'joy': 7.5, 'embarrassed': 3.6, 'restless': 4.1, 'apathetic': 3.8, 'calm': 7}\nfor key in sentiment:\n  print(\"key:\", key)\n\nkey: happy\nkey: sad\nkey: joy\nkey: embarrassed\nkey: restless\nkey: apathetic\nkey: calm\n\n\nThe .items() method for Dictionary is similar to the enumerate() function: it returns a list of tuples, and within each tuple the first element is a key, and the second element is a value.\n\nsentiment.items()\n\ndict_items([('happy', 8), ('sad', 2), ('joy', 7.5), ('embarrassed', 3.6), ('restless', 4.1), ('apathetic', 3.8), ('calm', 7)])\n\n\n\nfor key, value in sentiment.items():\n  print(key, \"corresponds to \", value)\n\nhappy corresponds to  8\nsad corresponds to  2\njoy corresponds to  7.5\nembarrassed corresponds to  3.6\nrestless corresponds to  4.1\napathetic corresponds to  3.8\ncalm corresponds to  7\n\n\n\n\n2.3.4 Ranges\nRanges are a collection of sequential numbers, such as:\n\n1, 2, 3, 4, 5\n1, 3, 5\n10, 15, 20, 25, 30\n\nIt seems natural to treat Ranges as Lists, but the neat thing about them is that only the bare minimum information is stored: the start, end, and step size. This could be a huge reduction in memory…if you need a sequence of numbers between 1 and 1 million, you can either store all 1 million values in a list, or you can just have a Range that holds the start: 1, the end: 1 million, and the step size: 1. That’s a big difference!\nYou can create a Range via the following ways:\n\nrange(stop) which starts at 0 and ends in stop - 1.\nrange(start, stop) which starts at start and ends in stop - 1\nrange(start, stop, step) which starts at start and ends in stop - 1, with a step size of step.\n\nWhen you create a Range object, it just tells you what the input values you gave it.\n\nrange(5, 50, 5)\n\nrange(5, 50, 5)\n\n\nConvert to a list to see its actual values:\n\nlist(range(5, 50, 5))\n\n[5, 10, 15, 20, 25, 30, 35, 40, 45]\n\n\nTo use Ranges in a For-Loop, it’s straightforward:\n\nfor i in range(5, 50, 5):\n  print(i)\n\n5\n10\n15\n20\n25\n30\n35\n40\n45",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "02-Iteration.html#exercises",
    "href": "02-Iteration.html#exercises",
    "title": "2  Iteration",
    "section": "2.4 Exercises",
    "text": "2.4 Exercises\nExercise for week 2 can be found here.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Iteration</span>"
    ]
  },
  {
    "objectID": "03-Conditionals.html",
    "href": "03-Conditionals.html",
    "title": "3  Conditional Statements",
    "section": "",
    "text": "3.1 Exercises\nExercise for week 3 can be found here.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conditional Statements</span>"
    ]
  },
  {
    "objectID": "04-Functions.html",
    "href": "04-Functions.html",
    "title": "4  Functions",
    "section": "",
    "text": "4.1 Anatomy of a function definition\nThis is how you define a function:\nHere’s an simple example to define a function that adds two numbers together:\ndef add_numbers(num1, num2):\n  \"\"\" Adds two input numbers together. \"\"\"\n  result = num1 + num2\n  return result\nWhen this code is run, add_numbers() is stored in the environment, but the function is never run. To run the function,\nadd_numbers(3, 4)\n\n7\nWhen the function is called, the input values 3 and 4 are reassigned to function input arguments num1 and num2 to be used within the function.\nWe need to introduce the concept of local and global environments to distinguish variables used only for a function from variables used for the entire program.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#anatomy-of-a-function-definition",
    "href": "04-Functions.html#anatomy-of-a-function-definition",
    "title": "4  Functions",
    "section": "",
    "text": "def &lt;function name&gt;(&lt;input arguments&gt;):\n    \"\"\" documentation string \"\"\"\n    code block\n    return &lt;variable&gt;\n\n&lt;function name&gt; is the function’s name you are creating.\n&lt;input arguments&gt; specify the input arguments for the function as variable, separated by commas.\n\"\"\" documentation string \"\"\" describes what the function is doing. It is considered optional but highly recommended.\ncode block performs the action of the function, typically using the input arguments of the function.\nreturn &lt;variable&gt; it the output of the function.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#local-and-global-environments",
    "href": "04-Functions.html#local-and-global-environments",
    "title": "4  Functions",
    "section": "4.2 Local and global environments",
    "text": "4.2 Local and global environments\nWithin a function, all input arguments and any new variables defined are stored in a “local environment”, and is only accessible within the function’s body. The overall environment of the program is called the “global environment” and can be also accessed within the function.\nThe reason of having some of this “privacy” in the local environment is to make functions modular - they are independent little tools that should not interact with the rest of the global environment. Imagine you writing a function that you want to give someone else to use, but your function depends on your global environment - it would not be portable!\nTo illustrate the distinction between a the local and global environment, the following tool allows you to step through Python code execution line-by-line and see the relationship between order of execution, variables, and environments. The “Global frame” refers to the global environment, and “add_numbers” refer to the local environment for the function add_numbers().\n\n\nIf it doesn’t load properly, here is the link.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#function-arguments-create-modularity",
    "href": "04-Functions.html#function-arguments-create-modularity",
    "title": "4  Functions",
    "section": "4.3 Function arguments create modularity",
    "text": "4.3 Function arguments create modularity\nFirst time writers of functions might ask: why are variables we use for the arguments of a function reassigned for function arguments in the local environment? Here is an example when that process is skipped - what are the consequences?\n\nx = 3\ny = 4\ndef add_numbers(num1, num2):\n  \"\"\" Adds two input numbers together. \"\"\"\n  result = x + y\n  return result\n\nLet’s try this function out for a few values:\n\nadd_numbers(x, y)\n\n7\n\n\n\nadd_numbers(10, -5)\n\n7\n\n\nWhy is this happening? Let’s try to step through this interactively:\n\n\nIf it doesn’t load properly, here is the link.\nThe function did not work as expected because we used hard-coded variables (x, y) from the global environment and not function argument variables unique to the function use!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#in-class-exercises",
    "href": "04-Functions.html#in-class-exercises",
    "title": "4  Functions",
    "section": "4.4 In-Class Exercises",
    "text": "4.4 In-Class Exercises\n\nWrite a function, my_abs(x) that computes the absolute value of an input numeric value and returns it. Use cases: my_abs(-3) = 3, my_abs(0) = 0, my_abs(33) = 33. You will need to use conditional statements within the body of the function.\nWrite a function, my_abs_iterated(x) that takes in a list of numerical values and use my_abs(x) to take the absolute value of each element. Use cases: my_abs_itereated([3, -9, 2]) = [3, -9, 2].",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "04-Functions.html#exercises",
    "href": "04-Functions.html#exercises",
    "title": "4  Functions",
    "section": "4.5 Exercises",
    "text": "4.5 Exercises\nExercise for week 4 can be found here.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "05-Iteration_Styles.html",
    "href": "05-Iteration_Styles.html",
    "title": "5  Iteration Styles",
    "section": "",
    "text": "5.1 List Comprehensions\nYou have been writing For-Loops to modify or create Lists. To modify an existing list, you write a pattern like this:\ndef cool_function(x):\n  return x + 1\n  \nmy_list = [3, -35, 98, 2.3, 0, -3]\n\nfor i, element in enumerate(my_list):\n  my_list[i] = cool_function(element)\nprint(my_list)\n\n[4, -34, 99, 3.3, 1, -2]\nTo create a list based on another list:\nnew_list = []\nfor element in my_list:\n  new_list.append(cool_function(element))\nprint(new_list)  \n\n[5, -33, 100, 4.3, 2, -1]\nWhen the final product of a For-Loop is a List, it is common to write a short-hand via a “List Comprehension”. The syntax looks like this:\nFor our first example, the For-Loop would be rewritten as:\nmy_list = [3, -35, 98, 2.3, 0, -3]\n\nmy_list = [cool_function(element) for element in my_list]\nFor our second example, the For-Loop would be rewritten as:\nmy_list = [3, -35, 98, 2.3, 0, -3]\n\nnew_list = [cool_function(element) for element in my_list]\nHere’s how the Python interpreter would work through this:\nList comprehensions encourages the following:\nNote that you don’t need to use a function when invoking a list comprehension. You could have something like:\n[element / 2 for element in my_list]\n\n[1.5, -17.5, 49.0, 1.15, 0.0, -1.5]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Iteration Styles</span>"
    ]
  },
  {
    "objectID": "05-Iteration_Styles.html#list-comprehensions",
    "href": "05-Iteration_Styles.html#list-comprehensions",
    "title": "5  Iteration Styles",
    "section": "",
    "text": "[&lt;expression&gt; for &lt;var&gt; in &lt;iterable&gt;]\n\n\n\n\n\n\nLook at the first member of my_list, and assign it as element.\nEvaluate cool_function(element), and the output value is stored as the first element of our output list.\nProceed to the next member of my_list and assign it as element. Repeat steps 2, 3 until we’re done.\n\n\n\nReadability that the output product is a List.\nEncouragement of writing functions for the body of the loop. A list comprehension can only take in one expression.\n\n\n\n\n5.1.0.1 With a conditional statement\nWe can add a second flavor of complexity into creating Lists in which a condition needs to be met in order for the element to be in the new list.\n\nmy_list = [3, -35, 98, 2.3, 0, -3]\nnew_list = []\n\nfor element in my_list:\n  if element &gt; 0:\n    new_list.append(cool_function(element))\n    \nprint(new_list)\n\n[4, 99, 3.3]\n\n\nWe would use the following List Comprehension syntax:\n[&lt;expression&gt; for &lt;var&gt; in &lt;iterable&gt; if &lt;condition&gt;]\nHere’s how it looks like:\n\nmy_list = [3, -35, 98, 2.3, 0, -3]\n\nnew_list = [cool_function(element) for element in my_list if element &gt; 0]\n\nprint(new_list)\n\n[4, 99, 3.3]\n\n\nHere’s how the Python interpreter would work through this:\n\nLook at the first member of my_list, and assign it as element.\nEvaluate element &gt; 0. If this is True, then proceed to step 3. If this is False, don’t evaluate and proceed to the next member of my_list and assign it as element.\nEvaluate cool_function(element), and the output value is stored as the first element of our output list.\nProceed to the next member of my_list and assign it as element. Repeat steps 2-4 until we’re done.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Iteration Styles</span>"
    ]
  },
  {
    "objectID": "05-Iteration_Styles.html#maps",
    "href": "05-Iteration_Styles.html#maps",
    "title": "5  Iteration Styles",
    "section": "5.2 Maps",
    "text": "5.2 Maps\nOne iterable data structure that we haven’t discussed in this course is how to use iteration on is Series - the column of a Dataframe. An extremely common iteration pattern on Series is to apply a function to each element of the Series to transform the data. Many existing functions are built to with a Series object in mind, such as the following example:\n\nimport pandas as pd\nimport numpy as np\n\nsimple_df = pd.DataFrame(data={'id': [\"AAA\", \"BBB\", \"CCC\", \"DDD\", \"EEE\"],\n                               'case_control': [\"case\", \"case\", \"control\", \"control\", \"control\"],\n                               'measurement1': [2.5, 3.5, 9, .1, 2.2],\n                               'measurement2': [0, 0, .5, .24, .003],\n                               'measurement3': [80, 2, 1, 1, 2]})\nsimple_df\n\n\n\n\n\n\n\n\nid\ncase_control\nmeasurement1\nmeasurement2\nmeasurement3\n\n\n\n\n0\nAAA\ncase\n2.5\n0.000\n80\n\n\n1\nBBB\ncase\n3.5\n0.000\n2\n\n\n2\nCCC\ncontrol\n9.0\n0.500\n1\n\n\n3\nDDD\ncontrol\n0.1\n0.240\n1\n\n\n4\nEEE\ncontrol\n2.2\n0.003\n2\n\n\n\n\n\n\n\nWe make a log transformation:\n\nnp.log(simple_df.measurement1)\n\n0    0.916291\n1    1.252763\n2    2.197225\n3   -2.302585\n4    0.788457\nName: measurement1, dtype: float64\n\n\nThe function np.log(x) takes in a Series as input. But what about functions that we already have but the input it takes in is an element of Series, such as cool_function(x)? We could write a For-Loop to do that, but it is actually discouraged in terms of performance. Rather, what is encouraged is to use the mapping function.\nA map (also known as a functional) is a function that takes in an iterable data structure and function as inputs and applies the function on the data structure, element by element. It maps your input iterable data structure to an output data structure based on the function.\nVisually, it looks like this:\n\nOr,\n\nYou can use the .map() method for Series to do this:\n\nsimple_df.measurement1.map(cool_function)\n\n0     3.5\n1     4.5\n2    10.0\n3     1.1\n4     3.2\nName: measurement1, dtype: float64\n\n\nThis map style of writing iterations is known as “functional programming”. You write a function that can work for a single element of your data, and you can scale it up iteratively via a mapping function.\nOne of the most common use-case of the .map() method is for data recoding. For instance, suppose we want to create cutoffs for the column “measurement1” using the following function:\n\ndef measurement1_cutoff_rule(x):\n  if x &gt; 0 and x &lt; 2:\n    return \"low\"\n  elif x &gt;= 2 and x &lt; 7:\n    return \"medium\"\n  elif x &gt;= 7:\n    return \"high\"\n  else:\n    return \"unknown\"\n\nWe can map this function measurement1_cutoff_rule() to each element of “measurement1”:\n\nsimple_df.measurement1.map(measurement1_cutoff_rule)\n\n0    medium\n1    medium\n2      high\n3       low\n4    medium\nName: measurement1, dtype: object\n\n\n\n5.2.1 Lambda Functions\nSometimes, a function you want to define is short and not used by any other part of the program, which is common in the .map() method. For instance, cool_function()’s content is only one line of code, and perhaps cool_function() is never used again elsewhere in the code. Defining def cool_function() seems a bit excessive.\nTurns out, you can define a very short function to be used just one time:\n\nsimple_df.measurement1.map(lambda x: x + 1)\n\n0     3.5\n1     4.5\n2    10.0\n3     1.1\n4     3.2\nName: measurement1, dtype: float64\n\n\nThe lambda statement signifies that you are writing a single-expression function that is going to be used only once. The variable x is the input argument, and x + 1 is the body of the function. The output of the single expression is the return value of the function. Nice and simple!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Iteration Styles</span>"
    ]
  },
  {
    "objectID": "05-Iteration_Styles.html#which-iteration-method-should-you-use",
    "href": "05-Iteration_Styles.html#which-iteration-method-should-you-use",
    "title": "5  Iteration Styles",
    "section": "5.3 Which iteration method should you use?",
    "text": "5.3 Which iteration method should you use?\nWe’ve talked about writing For-Loops, List-Comprehensions, Maps, and we know there are existing functions and methods that can be used on an entire data structure. So which iteration method should you use when you are working with data? Here are some general guidelines, in order of consideration:\n\nWhen you can, use existing functions and methods that can carry out the iteration task. For example, if you want to compute the mean value of a Dataframe’s column, use the .mean() method. It will be much more efficient iterating via a For-Loop. These existing functions and methods from standard modules are highly optimized to be efficient beyond the scope of this class.\nIf you need to use a function on each element of a dataframe’s column, such as data recoding, use the .map() method to help with the iteration.\nIf your desired output is a List, consider writing a List Comprehension. They tend to perform a bit faster than For-Loops because you have told it in advance what the resulting data structure will be.\nWhen working with iterable data structures, For-Loops are the most general purpose.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Iteration Styles</span>"
    ]
  },
  {
    "objectID": "05-Iteration_Styles.html#appendix",
    "href": "05-Iteration_Styles.html#appendix",
    "title": "5  Iteration Styles",
    "section": "5.4 Appendix",
    "text": "5.4 Appendix\nIf you really want to use a For-Loop on a Series, you can use the .items() method on a Series to get the index and value, similar to the enumerate() function. Then when you modify a column, you would need to use the dataframe’s .loc[ ] attribute to access the elements to be modified. Here is a simple example:\n\nfor i, value in simple_df.measurement1.items():\n  print(f\"Index : {i}, Value : {value}\")\n  simple_df.loc[i, \"measurement1\"] = value * 2\n\nIndex : 0, Value : 2.5\nIndex : 1, Value : 3.5\nIndex : 2, Value : 9.0\nIndex : 3, Value : 0.1\nIndex : 4, Value : 2.2",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Iteration Styles</span>"
    ]
  },
  {
    "objectID": "05-Iteration_Styles.html#exercises",
    "href": "05-Iteration_Styles.html#exercises",
    "title": "5  Iteration Styles",
    "section": "5.5 Exercises",
    "text": "5.5 Exercises\nExercise for week 5 can be found here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Iteration Styles</span>"
    ]
  },
  {
    "objectID": "06-Reference_vs_Copy.html",
    "href": "06-Reference_vs_Copy.html",
    "title": "6  Reference vs. Copy",
    "section": "",
    "text": "6.1 Assignment by Reference (for mutable objects)\nWhen we created the variable a to equal the list [1, 2, 3], it is tempting to say, “the variable ‘a’ is a list with value [1, 2, 3]”, but that is technically incorrect!\nThe correct way: “the variable ‘a’ is a reference to a list with value [1, 2, 3]”.\nWe now make a distinction between the variable and the object: the variable gives the reference information to the object, and other variables can reference the same object also! When we evaluated b = a, we told b to reference thee same object as a, so modifying b modified a also.\nThis reference information tells us where the object is stored in the working memory of the computer, usually in the address form of a number.\nLet’s see this in action:\nIf it doesn’t load properly, here is the link.\nHere’s another illustration of the situation:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Reference vs. Copy</span>"
    ]
  },
  {
    "objectID": "06-Reference_vs_Copy.html#assignment-by-reference-for-mutable-objects",
    "href": "06-Reference_vs_Copy.html#assignment-by-reference-for-mutable-objects",
    "title": "6  Reference vs. Copy",
    "section": "",
    "text": "&lt;p&gt;If it doesn’t load properly, here is the &lt;a href=\"https://pythontutor.com/render.html#code=a%20%3D%20%5B1,%202,%203%5D%0Ab%20%3D%20a%0Ab.append%284%29&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false\"&gt;link&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;What is happening behind the scenes:&lt;/p&gt;\n&lt;ol type=\"1\"&gt;\n&lt;li&gt;&lt;code&gt;a = [1, 2, 3]&lt;/code&gt;\n&lt;ol type=\"1\"&gt;\n&lt;li&gt;The list with value [1, 2, 3] is created in the memory of the computer, with a particular memory address, say 999.&lt;/li&gt;\n&lt;li&gt;The variable &lt;code&gt;a&lt;/code&gt; holds the reference to that memory address, 999.&lt;/li&gt;\n&lt;/ol&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;b = a&lt;/code&gt;\n&lt;ol type=\"1\"&gt;\n&lt;li&gt;The variable &lt;code&gt;b&lt;/code&gt; has the same memory address as &lt;code&gt;a&lt;/code&gt;, 999.&lt;/li&gt;\n&lt;/ol&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;b.append(4)&lt;/code&gt;\n&lt;ol type=\"1\"&gt;\n&lt;li&gt;Access the list that is addressed as 999 and append 4 to it.&lt;/li&gt;\n&lt;/ol&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;print(a)&lt;/code&gt;, &lt;code&gt;print(b)&lt;/code&gt;\n&lt;ol type=\"1\"&gt;\n&lt;li&gt;Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same address and will access the same object.&lt;/li&gt;\n&lt;/ol&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;We can look at the memory address of our variables via the &lt;code&gt;id()&lt;/code&gt; function:&lt;/p&gt;\n&lt;div id=\"9ada91b1\" class=\"cell\" data-execution_count=\"4\"&gt;\n&lt;div class=\"sourceCode\" id=\"cb7\"&gt;&lt;pre class=\"sourceCode python cell-code\"&gt;&lt;code class=\"sourceCode python\"&gt;&lt;span id=\"cb7-1\"&gt;&lt;a href=\"#cb7-1\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;&lt;span class=\"bu\"&gt;id&lt;/span&gt;(a), &lt;span class=\"bu\"&gt;id&lt;/span&gt;(b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\n&lt;div class=\"cell-output cell-output-display\" data-execution_count=\"4\"&gt;\n&lt;pre&gt;&lt;code&gt;(139986754985792, 139986754985792)&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;They are the same.&lt;/p&gt;\n&lt;p&gt;Here is another visual way to think about this:&lt;/p&gt;\n&lt;p&gt;&lt;img src=\"images/references.png\" class=\"img-fluid\" alt=\"If you imagine variables are like boxes, you can’t make sense of assignment in Python; instead, think of variables as sticky notes. Image source: Fluent Python, Chapter 8.\" /&gt;If you imagine variables are like boxes, you can’t make sense of assignment in Python; instead, think of variables as sticky notes. Image source: Fluent Python, Chapter 8.&lt;/p&gt;\n&lt;section id=\"an-object-isnt-unique\" class=\"level3\" data-number=\"6.1.1\"&gt;\n&lt;h3 data-number=\"6.1.1\"&gt;&lt;span class=\"header-section-number\"&gt;6.1.1&lt;/span&gt; An object isn’t unique&lt;/h3&gt;\n&lt;p&gt;Let’s see another example, using Dictionaries this time:&lt;/p&gt;\n&lt;div id=\"719a7511\" class=\"cell\" data-execution_count=\"5\"&gt;\n&lt;div class=\"sourceCode\" id=\"cb9\"&gt;&lt;pre class=\"sourceCode python cell-code\"&gt;&lt;code class=\"sourceCode python\"&gt;&lt;span id=\"cb9-1\"&gt;&lt;a href=\"#cb9-1\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;charles &lt;span class=\"op\"&gt;=&lt;/span&gt; {&lt;span class=\"st\"&gt;&#39;name&#39;&lt;/span&gt;: &lt;span class=\"st\"&gt;&#39;Charles L. Dodgson&#39;&lt;/span&gt;, &lt;span class=\"st\"&gt;&#39;born&#39;&lt;/span&gt;: &lt;span class=\"dv\"&gt;1832&lt;/span&gt;}&lt;/span&gt;\n&lt;span id=\"cb9-2\"&gt;&lt;a href=\"#cb9-2\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;lewis &lt;span class=\"op\"&gt;=&lt;/span&gt; charles&lt;/span&gt;\n&lt;span id=\"cb9-3\"&gt;&lt;a href=\"#cb9-3\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;&lt;span class=\"bu\"&gt;id&lt;/span&gt;(charles), &lt;span class=\"bu\"&gt;id&lt;/span&gt;(lewis)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\n&lt;div class=\"cell-output cell-output-display\" data-execution_count=\"5\"&gt;\n&lt;pre&gt;&lt;code&gt;(139986754588544, 139986754588544)&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"497df35e\" class=\"cell\" data-execution_count=\"6\"&gt;\n&lt;div class=\"sourceCode\" id=\"cb11\"&gt;&lt;pre class=\"sourceCode python cell-code\"&gt;&lt;code class=\"sourceCode python\"&gt;&lt;span id=\"cb11-1\"&gt;&lt;a href=\"#cb11-1\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;lewis[&lt;span class=\"st\"&gt;&#39;balance&#39;&lt;/span&gt;] &lt;span class=\"op\"&gt;=&lt;/span&gt; &lt;span class=\"dv\"&gt;950&lt;/span&gt;&lt;/span&gt;\n&lt;span id=\"cb11-2\"&gt;&lt;a href=\"#cb11-2\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;charles&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\n&lt;div class=\"cell-output cell-output-display\" data-execution_count=\"6\"&gt;\n&lt;pre&gt;&lt;code&gt;{&#39;name&#39;: &#39;Charles L. Dodgson&#39;, &#39;born&#39;: 1832, &#39;balance&#39;: 950}&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;As expected, we see that Charles also has a balance of 950, because both variables have the same reference to the same object.&lt;/p&gt;\n&lt;p&gt;Now, suppose we create a variable &lt;code&gt;alex&lt;/code&gt; with a reference to a dictionary with the &lt;em&gt;same value&lt;/em&gt;:&lt;/p&gt;\n&lt;div id=\"37ff84b4\" class=\"cell\" data-execution_count=\"7\"&gt;\n&lt;div class=\"sourceCode\" id=\"cb13\"&gt;&lt;pre class=\"sourceCode python cell-code\"&gt;&lt;code class=\"sourceCode python\"&gt;&lt;span id=\"cb13-1\"&gt;&lt;a href=\"#cb13-1\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;alex &lt;span class=\"op\"&gt;=&lt;/span&gt; {&lt;span class=\"st\"&gt;&#39;name&#39;&lt;/span&gt;: &lt;span class=\"st\"&gt;&#39;Charles L. Dodgson&#39;&lt;/span&gt;, &lt;span class=\"st\"&gt;&#39;born&#39;&lt;/span&gt;: &lt;span class=\"dv\"&gt;1832&lt;/span&gt;, &lt;span class=\"st\"&gt;&#39;balance&#39;&lt;/span&gt;: &lt;span class=\"dv\"&gt;950&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;What do we expect?&lt;/p&gt;\n&lt;div id=\"e274d22f\" class=\"cell\" data-execution_count=\"8\"&gt;\n&lt;div class=\"sourceCode\" id=\"cb14\"&gt;&lt;pre class=\"sourceCode python cell-code\"&gt;&lt;code class=\"sourceCode python\"&gt;&lt;span id=\"cb14-1\"&gt;&lt;a href=\"#cb14-1\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;&lt;span class=\"bu\"&gt;id&lt;/span&gt;(lewis), &lt;span class=\"bu\"&gt;id&lt;/span&gt;(charles), &lt;span class=\"bu\"&gt;id&lt;/span&gt;(alex)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\n&lt;div class=\"cell-output cell-output-display\" data-execution_count=\"8\"&gt;\n&lt;pre&gt;&lt;code&gt;(139986754588544, 139986754588544, 139986754796032)&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;This shows that you can have objects of the same values, that is:&lt;/p&gt;\n&lt;div id=\"c75c3bcd\" class=\"cell\" data-execution_count=\"9\"&gt;\n&lt;div class=\"sourceCode\" id=\"cb16\"&gt;&lt;pre class=\"sourceCode python cell-code\"&gt;&lt;code class=\"sourceCode python\"&gt;&lt;span id=\"cb16-1\"&gt;&lt;a href=\"#cb16-1\" aria-hidden=\"true\" tabindex=\"-1\"&gt;&lt;/a&gt;lewis &lt;span class=\"op\"&gt;==&lt;/span&gt; alex&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\n&lt;div class=\"cell-output cell-output-display\" data-execution_count=\"9\"&gt;\n&lt;pre&gt;&lt;code&gt;True&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;p&gt;but they are distinct objects that are stored in a different part of the memory. Therefore you can modify &lt;code&gt;alex&lt;/code&gt;, but &lt;code&gt;lewis&lt;/code&gt; and &lt;code&gt;charles&lt;/code&gt; won’t be changed.&lt;/p&gt;\n&lt;p&gt;Let’s see this step-by-step:&lt;/p&gt;\n\n&lt;iframe width=\"800\" height=\"500\" frameborder=\"0\" src=\"https://pythontutor.com/iframe-embed.html#code=charles%20%3D%20%7B'name'%3A%20'Charles%20L.%20Dodgson',%20'born'%3A%201832%7D%0Alewis%20%3D%20charles%0Alewis%5B'balance'%5D%20%3D%20950%0Aalex%20%3D%20%7B'name'%3A%20'Charles%20L.%20Dodgson',%20'born'%3A%201832,%20'balance'%3A%20950%7D%0Aalex%5B'balnce'%5D%20%3D%200&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=nevernest&origin=opt-frontend.js&py=311&rawInputLstJSON=%5B%5D&textReferences=false\"\n\n\n\n\n\n\n\nIf you imagine variables are like boxes, you can’t make sense of assignment in Python; instead, think of variables as sticky notes. Image source: Fluent Python, Chapter 8.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Reference vs. Copy</span>"
    ]
  },
  {
    "objectID": "06-Reference_vs_Copy.html#notes-on-dataframes",
    "href": "06-Reference_vs_Copy.html#notes-on-dataframes",
    "title": "6  Reference vs. Copy",
    "section": "6.2 Notes on Dataframes",
    "text": "6.2 Notes on Dataframes\nWhen we work with Pandas Dataframes, variables are also assigned by reference: suppose we have a small dataframe simple_df:\n\nimport pandas as pd\nimport numpy as np\n\nsimple_df = pd.DataFrame(data={'id': [\"AAA\", \"BBB\", \"CCC\", \"DDD\", \"EEE\"],\n                               'case_control': [\"case\", \"case\", \"control\", \"control\", \"control\"],\n                               'measurement1': [2.5, 3.5, 9, .1, 2.2],\n                               'measurement2': [0, 0, .5, .24, .003],\n                               'measurement3': [80, 2, 1, 1, 2]})\n\nWe assign analysis_df as simple_df, and log-transform the column “measurement1”, and see how it affects both dataframes:\n\nanalysis_df = simple_df\nanalysis_df.measurement1 = np.log(analysis_df.measurement1)\nprint(analysis_df)\n\n    id case_control  measurement1  measurement2  measurement3\n0  AAA         case      0.916291         0.000            80\n1  BBB         case      1.252763         0.000             2\n2  CCC      control      2.197225         0.500             1\n3  DDD      control     -2.302585         0.240             1\n4  EEE      control      0.788457         0.003             2\n\n\n\nprint(simple_df)\n\n    id case_control  measurement1  measurement2  measurement3\n0  AAA         case      0.916291         0.000            80\n1  BBB         case      1.252763         0.000             2\n2  CCC      control      2.197225         0.500             1\n3  DDD      control     -2.302585         0.240             1\n4  EEE      control      0.788457         0.003             2\n\n\nTo prevent this behavior, we can use the .copy() method:\n\nsimple_df = pd.DataFrame(data={'id': [\"AAA\", \"BBB\", \"CCC\", \"DDD\", \"EEE\"],\n                               'case_control': [\"case\", \"case\", \"control\", \"control\", \"control\"],\n                               'measurement1': [2.5, 3.5, 9, .1, 2.2],\n                               'measurement2': [0, 0, .5, .24, .003],\n                               'measurement3': [80, 2, 1, 1, 2]})\n                               \nanalysis_df = simple_df.copy()\nanalysis_df.measurement1 = np.log(analysis_df.measurement1)\nprint(analysis_df)\n\n    id case_control  measurement1  measurement2  measurement3\n0  AAA         case      0.916291         0.000            80\n1  BBB         case      1.252763         0.000             2\n2  CCC      control      2.197225         0.500             1\n3  DDD      control     -2.302585         0.240             1\n4  EEE      control      0.788457         0.003             2\n\n\nSo simple_df does not change:\n\nprint(simple_df)\n\n    id case_control  measurement1  measurement2  measurement3\n0  AAA         case           2.5         0.000            80\n1  BBB         case           3.5         0.000             2\n2  CCC      control           9.0         0.500             1\n3  DDD      control           0.1         0.240             1\n4  EEE      control           2.2         0.003             2\n\n\n\n6.2.1 Copy vs. Reference in Dataframe operations and methods\nHowever, some Dataframe operations and methods will automatically give you a copy, while others give you a reference.\nFor instance, when we subset via .loc, it returns a copy:\n\ncase_df = simple_df.loc[simple_df.case_control == \"case\"]\ncase_df.loc[:, 'measurement1'] = 5\nprint(case_df)\n\n    id case_control  measurement1  measurement2  measurement3\n0  AAA         case           5.0           0.0            80\n1  BBB         case           5.0           0.0             2\n\n\n\nprint(simple_df)\n\n    id case_control  measurement1  measurement2  measurement3\n0  AAA         case           2.5         0.000            80\n1  BBB         case           3.5         0.000             2\n2  CCC      control           9.0         0.500             1\n3  DDD      control           0.1         0.240             1\n4  EEE      control           2.2         0.003             2\n\n\nHowever, if you subset to one specific column, it gives you a reference:\n\nm1 = simple_df[\"measurement1\"]\nm1[0] = 5\nprint(m1)\n\n0    5.0\n1    3.5\n2    9.0\n3    0.1\n4    2.2\nName: measurement1, dtype: float64\n\n\n/tmp/ipykernel_359/1078013331.py:2: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  m1[0] = 5\n\n\n\nprint(simple_df)\n\n    id case_control  measurement1  measurement2  measurement3\n0  AAA         case           5.0         0.000            80\n1  BBB         case           3.5         0.000             2\n2  CCC      control           9.0         0.500             1\n3  DDD      control           0.1         0.240             1\n4  EEE      control           2.2         0.003             2\n\n\nThis pattern is called “Chained Assignment”, which means doing two bracket subsetting one after the other.\nThis behavior is super inconsistent and confusing, as it’s hard to predict when you will get a reference and when you get a copy. More details of this behavior can be found here. Future versions of Pandas Dataframe will remove these confusion, but for now, when you are modifying Dataframes, consider making a copy when you are unsure what its behaviors are when assigning variables to Dataframes.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Reference vs. Copy</span>"
    ]
  },
  {
    "objectID": "06-Reference_vs_Copy.html#exercises",
    "href": "06-Reference_vs_Copy.html#exercises",
    "title": "6  Reference vs. Copy",
    "section": "6.3 Exercises",
    "text": "6.3 Exercises\nExercise for week 6 can be found here.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Reference vs. Copy</span>"
    ]
  }
]